---
title: "Clojure Macros: How Evil?"
kind: article
created_at: 2011-10-29 22:39:00 UTC
author: Steven Deobald
layout: post
---
<div dir="ltr" style="text-align: left;" trbidi="on"><a href="http://www.dan-manges.com/blog">Dan</a> asked me at the Chicago Clojure Meetup this week if Clojure macros tend to send developers into the death spiral of metaprogramming Ruby's various hooks did when we first discovered those.<br /><br /><div style="text-align: center;"><span class="Apple-style-span" style="font-size: x-large;">tl;dr: no.</span></div><br />The canonical example of evil Ruby metaprogramming is everyone's favourite this-will-trim-8-lines-of-code hack: strings to method names. Have you ever written something like this?<br /><br /><div style="text-align: center;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">x.send("#{a}_#{b}")</span></div><br />Sure you have. It's okay. We've all sinned. Are you prevented from doing this sort of thing in Clojure? Nope. No more than you are prevented from doing it in Java. But in Clojure and Java, the apparent innocence of Ruby's `send` method is revealed to be a sham: Reflection <i>feels</i> bad in these languages.<br /><br />All of Ruby's other metaprogramming hooks have something in common: define_method, const_get, method_missing,&nbsp;every flavour of eval, monkey-patching... and all their friends... happen at runtime.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-k28Dl5ZWxn4/Tqx76JlgGEI/AAAAAAAAClc/pAjQ6KLmLho/s1600/yin_yang_cats.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="253" src="http://1.bp.blogspot.com/-k28Dl5ZWxn4/Tqx76JlgGEI/AAAAAAAAClc/pAjQ6KLmLho/s320/yin_yang_cats.jpg" width="320" /></a></div><br /><br />The behaviour of my first few Clojure macros confused me because&nbsp;I was accustomed to Ruby's runtime powers. Clojure's macros&nbsp;are expanded, go figure, at <i>macro expansion time</i>. As such, they have a few interesting and related properties:<br /><br /><ul style="text-align: left;"><li>macros feel like&nbsp;<span class="Apple-style-span" style="color: #38761d;">adding a feature to the language</span></li><li>ruby metaprogramming feels like <span class="Apple-style-span" style="color: #990000;">mutating the language</span></li><li>macros <span class="Apple-style-span" style="color: #38761d;">cannot use runtime data</span> to generate dynamic code</li><li>ruby metaprogramming&nbsp;<span class="Apple-style-span" style="color: #990000;">requires runtime data</span> to generate dynamic code</li><li>macros <span class="Apple-style-span" style="color: #38761d;">require a new way of thinking</span> about code generation</li><li>ruby metaprogramming is just a <span class="Apple-style-span" style="color: #990000;">higher-level imperative layer</span>&nbsp;</li></ul><div>Macros also have a very clear usage pattern (see Christophe's wonderful <a href="http://www.slideshare.net/cgrand/dsl-5537797">(not= DSL macros) presentation</a> from the first ClojureConj):</div><div><br /></div><div style="text-align: center;"><span class="Apple-style-span" style="font-size: x-large;">data formats &gt; functions &gt; macros</span></div><div><br /></div><div>This is to say: Build your functions on top of your data. Build your macros on top of your functions. Macros should always be a convenience rather than a requirement. This one little rule is often enough to remind yourself that "write a macro!" usually isn't the solution you're looking for.</div><div><br /></div><div>We're probably better off to avoid comparing Ruby's metaprogramming facilities with macros at all. It makes more sense to compare Ruby's hooks to Clojure's reflection and Ruby's eval to Clojure's eval -- neither of which I've seen used in a production Clojure application. Macros actually stand out on their own, since Ruby doesn't have an equivalent feature.</div><div><br /></div><div>Can you still write a steaming pile of magic in Clojure? Of course. Once you suffocate your desire for elegance, you can reflect and eval and macro your way into a painful and confusing&nbsp;labyrinth&nbsp;of obfuscated code just as you can in any other modern language. But Clojure's libraries and language features usually display enough power on their own that you aren't tempted to shortcut your way into an impenetrable structural abstraction. At least, I haven't seen it yet.</div></div><div class="author">
  <img src="http://nilenso.com/people/steven-200.png" style="width: 96px; height: 96;">
  <span style="position: absolute; padding: 32px 15px;">
    <i>Original post by <a href="http://twitter.com/">Steven Deobald</a> - check out <a href="http://blog.deobald.ca/">Hungry, horny, sleepy, curious.</a></i>
  </span>
</div>
