---
title: "defining the interface for rubymonk"
kind: article
created_at: 2012-05-05 05:43:00 UTC
author: Steven Deobald
layout: post
---
<div dir="ltr" style="text-align: left;" trbidi="on"><i>Discussing an interview I had yesterday --quite interesting when delivered with <a href="https://twitter.com/#!/aninda42">Aninda</a>-- with a&nbsp;</i><i>non-technical&nbsp;</i><i>friend, we stumbled on the fact that everything in Computer Science is an interface. From the moment you differentiate data from code, which wasn't immediately obvious to even the first computer programmers twiddling individual bits....</i><br /><br />Everything you build in software is defined by an interface. These are the boundaries, but they're also where the magic happens.<br /><br />Here are some interfaces:<br /><br /><div style="background-color: #f2f2f2; border: #c4c4c4 solid 4px; clear: both; padding: 12px;"><div style="text-align: center;"><span style="font-family: 'Courier New', Courier, monospace; font-size: large;">http://www.c42.in/a_url_is_an_interface/</span></div><div style="text-align: center;">(We'll come back to this.)</div></div><br /><br /><br /><div style="background-color: #f2f2f2; border: #c4c4c4 solid 4px; clear: both; padding: 12px;"><span style="font-family: 'Courier New', Courier, monospace; font-size: large;">$ ps aux | grep clojure</span></div><br /><br /><br /><div style="background-color: #f2f2f2; border: #c4c4c4 solid 4px; clear: both; padding: 12px;"><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-46biZWJfmMg/T6DENG2It-I/AAAAAAAAC-E/CLmGWoOZM_k/s1600/functions.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://2.bp.blogspot.com/-46biZWJfmMg/T6DENG2It-I/AAAAAAAAC-E/CLmGWoOZM_k/s320/functions.png" width="226" /></a></div><br /><i>At this point, I had to stop to explain how a <b>function</b> works. Does this help?&nbsp;</i><i>(Hey Blogger or Google or whoever the heck is in charge: why can't that image be an SVG?)</i><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-XELHcW1MOkw/T6DGmwIxr-I/AAAAAAAAC-M/z8uKbchI1PY/s1600/functions-with-values.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://3.bp.blogspot.com/-XELHcW1MOkw/T6DGmwIxr-I/AAAAAAAAC-M/z8uKbchI1PY/s320/functions-with-values.png" width="226" /></a></div></div><br /><br /><br /><div style="background-color: #f2f2f2; border: #c4c4c4 solid 4px; clear: both; padding: 12px;"><b>Objects</b> are the next interface to consider. They are a bundle of functions. Actually, they're more <a href="http://blip.tv/clojure/stuart-halloway-simplicity-ain-t-easy-4842694">complex</a> than that. They are a bunch of <a href="http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent">closures</a>... actually, <a href="http://letoverlambda.com/index.cl/guest/chap5.html#sec_7">dispatching closures</a>. <i>(Okay, I've lost my non-technical friend at this point. Oh well.)</i> There are other ways of looking at them, but we'll take the perspective of the function, which we already agree is quite simple. To the function, the object looks like a set of rules about how one defines interfaces with functions. Objects can be made of functions but it's not quite so the other way around (though the object may consider this point contentious or even academic). The function doesn't care. To him, an object is just a cluster -- however small -- of functions who have been told in advance that part of how they behave must change, because of the way they were set up... this time, at least. And what's worse, just because an object has been set up -- it won't necessarily stay that way! Yikes. Looking at it from the outside, the function pities the object. The function can choose to behave this way but the default position of the function is, "I never change!" The object changes himself (or worse, allows other, unknown objects to change him). It takes some work for the function to behave so sloppily; you need multiple functions -- and functions returning functions, no less (as a type's constructor returns a function whose sole purpose is dispatch based on the type of the first parameter and the name of the second -- usually with these parameters taking special positions, like <span style="font-family: 'Courier New', Courier, monospace;">first_is_an_object.second_is_a_method</span>. I digress.). Such effort forces a conscious choice on the part of the person writing that function. "This risk is worth it!" you say, and an interface of your choice, with complexity of your choice, emerges.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-PTcy8cxJwDw/T6F9OtA2aAI/AAAAAAAAC-c/5KOe9gHSZD0/s1600/object.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://2.bp.blogspot.com/-PTcy8cxJwDw/T6F9OtA2aAI/AAAAAAAAC-c/5KOe9gHSZD0/s320/object.png" width="226" /></a></div></div><br /><br /><br /><div style="background-color: #f2f2f2; border: #c4c4c4 solid 4px; clear: both; padding: 12px;">Finally, at the top of this scale are <b>languages</b>. They themselves are composed of functions and objects. In fact, most compilers and interpreters for languages can be thought of as pure functions: I give you the language, you give me the binary, assembly, bytecode, or runtime language (JS, these days). This is the most complex interface. Usually, a human still speaks to this interface. In 2012, this interface is fully-manual. These humans are called programmers. And the best of them will make it their task to automate away their own job. But, as of 2012, programs that write programs are risky and difficult. Automation can be seen on any of these other scales (functions and data) without writing your own macro or yet <i>another</i> compiler or parser. Choose a language which gives you this option when you have no other choice, but be careful to wield such a weapon when you see no other way out. Otherwise, it is a simple interface you want.</div><br /><br /><br /><a href="https://twitter.com/#!/kitallis">Kitty</a> pointed out to me that I haven't called out a very important point: All these interfaces are fundamentally the same. They accept some input and produce some output (even if that output is a side-effect). Objects are built of functions, and they're both built of languages. And the languages are built of objects and functions. What differentiates each one is the mental energy required to contend with the interface's complexity. Stateless interfaces -- such as immutable objects, pure functions, and HTTP -- are always easier to understand because there are fewer balls in the air. The "given" of given-when-then doesn't apply if there's nothing to set up. There's only when and then.<br /><br /><br /><br />This makes the interface for&nbsp;<a href="http://www.rubymonk.com/">RubyMonk</a>&nbsp;interesting. There is of course a very cute visual style to rubymonk.com (yeah, we love it too), but the real interface is the user's interaction with the mentor -- how we evaluate their progress and the programs they write. How we assert that something they've done is <i>correct -- </i>because the programs they write are data to us.&nbsp;As we teach more complex concepts, this interface itself will become increasingly complex by its very nature. Or, perhaps, we will realize the beautiful intrinsic quality of data that is code and code that is data, leading us to discover an elegant solution to the automation of the Hacker Mentor.<br /><br /><br /></div><div class="author">
  <img src="http://nilenso.com/people/steven-200.png" style="width: 96px; height: 96;">
  <span style="position: absolute; padding: 32px 15px;">
    <i>Original post by <a href="http://twitter.com/deobald">Steven Deobald</a> - check out <a href="http://blog.deobald.ca/">Hungry, horny, sleepy, curious.</a></i>
  </span>
</div>
